# DECISIONS.md - Ключевые архитектурные решения

## 1. Стек технологий: Node.js + Express + SQLite
**Решение:** Использовать Node.js с фреймворком Express для бэкенда и SQLite для базы данных.

**Причины:**
- Не требует установки отдельного сервера БД (SQLite — файл)
- Быстрый старт и простая настройка для локальной разработки
- Достаточно для демонстрации функционала
- Легко контейнеризировать в Docker

## 2. Защита от гонок: Optimistic Locking с версией
**Решение:** Добавить поле `version` в таблицу заявок и проверять его при смене статуса.

**Причины:**
- Простая и эффективная реализация
- Не требует блокировок на уровне БД
- Позволяет вернуть 409 Conflict при конфликте
- Легко тестировать скриптом race_test.sh

## 3. Простая авторизация: сессионная на основе cookies
**Решение:** Выбор пользователя из списка при входе, хранение userId в cookie.

**Причины:**
- Соответствует требованию "простая авторизация"
- Не требует сложных механизмов (JWT, OAuth)
- Достаточно для демонстрации разделения ролей

## 4. Frontend: Vanilla JS + Bootstrap 5
**Решение:** Использовать чистый JavaScript без фреймворков с Bootstrap для стилей.

**Причины:**
- Минимум зависимостей и сборки
- Быстрая разработка прототипа
- Bootstrap даёт готовые компоненты (формы, таблицы, модальные окна)
- Достаточно для 3 страниц приложения

## 5. Структура проекта: разделение на слои
**Решение:** Разделить код на controller → service → repository слои.

**Причины:**
- Чёткое разделение ответственности
- Легче тестировать сервисный слой
- Соответствует лучшим практикам
- Упрощает поддержку и расширение

## 6. API: RESTful с JSON ответами
**Решение:** Использовать REST-подход для эндпоинтов заявок.

**Причины:**
- Стандарт де-факто для веб-API
- Простота тестирования через curl
- Понятная структура URL (/api/requests, /api/requests/:id/take)

## 7. Docker Compose: одна служба приложения
**Решение:** Использовать Docker Compose с одним сервисом (приложение + SQLite внутри).

**Причины:**
- Соответствует требованию "docker compose up"
- Упрощает запуск для проверяющего
- SQLite не требует отдельного контейнера
